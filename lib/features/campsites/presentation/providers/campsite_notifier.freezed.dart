// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'campsite_notifier.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CampsiteState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Campsite> campsites) loaded,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Campsite> campsites)? loaded,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Campsite> campsites)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CampsiteInitial value) initial,
    required TResult Function(CampsiteLoading value) loading,
    required TResult Function(CampsiteLoaded value) loaded,
    required TResult Function(CampsiteError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CampsiteInitial value)? initial,
    TResult? Function(CampsiteLoading value)? loading,
    TResult? Function(CampsiteLoaded value)? loaded,
    TResult? Function(CampsiteError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CampsiteInitial value)? initial,
    TResult Function(CampsiteLoading value)? loading,
    TResult Function(CampsiteLoaded value)? loaded,
    TResult Function(CampsiteError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CampsiteStateCopyWith<$Res> {
  factory $CampsiteStateCopyWith(
          CampsiteState value, $Res Function(CampsiteState) then) =
      _$CampsiteStateCopyWithImpl<$Res, CampsiteState>;
}

/// @nodoc
class _$CampsiteStateCopyWithImpl<$Res, $Val extends CampsiteState>
    implements $CampsiteStateCopyWith<$Res> {
  _$CampsiteStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CampsiteState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$CampsiteInitialImplCopyWith<$Res> {
  factory _$$CampsiteInitialImplCopyWith(_$CampsiteInitialImpl value,
          $Res Function(_$CampsiteInitialImpl) then) =
      __$$CampsiteInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CampsiteInitialImplCopyWithImpl<$Res>
    extends _$CampsiteStateCopyWithImpl<$Res, _$CampsiteInitialImpl>
    implements _$$CampsiteInitialImplCopyWith<$Res> {
  __$$CampsiteInitialImplCopyWithImpl(
      _$CampsiteInitialImpl _value, $Res Function(_$CampsiteInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of CampsiteState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CampsiteInitialImpl implements CampsiteInitial {
  const _$CampsiteInitialImpl();

  @override
  String toString() {
    return 'CampsiteState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CampsiteInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Campsite> campsites) loaded,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Campsite> campsites)? loaded,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Campsite> campsites)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CampsiteInitial value) initial,
    required TResult Function(CampsiteLoading value) loading,
    required TResult Function(CampsiteLoaded value) loaded,
    required TResult Function(CampsiteError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CampsiteInitial value)? initial,
    TResult? Function(CampsiteLoading value)? loading,
    TResult? Function(CampsiteLoaded value)? loaded,
    TResult? Function(CampsiteError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CampsiteInitial value)? initial,
    TResult Function(CampsiteLoading value)? loading,
    TResult Function(CampsiteLoaded value)? loaded,
    TResult Function(CampsiteError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class CampsiteInitial implements CampsiteState {
  const factory CampsiteInitial() = _$CampsiteInitialImpl;
}

/// @nodoc
abstract class _$$CampsiteLoadingImplCopyWith<$Res> {
  factory _$$CampsiteLoadingImplCopyWith(_$CampsiteLoadingImpl value,
          $Res Function(_$CampsiteLoadingImpl) then) =
      __$$CampsiteLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CampsiteLoadingImplCopyWithImpl<$Res>
    extends _$CampsiteStateCopyWithImpl<$Res, _$CampsiteLoadingImpl>
    implements _$$CampsiteLoadingImplCopyWith<$Res> {
  __$$CampsiteLoadingImplCopyWithImpl(
      _$CampsiteLoadingImpl _value, $Res Function(_$CampsiteLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of CampsiteState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CampsiteLoadingImpl implements CampsiteLoading {
  const _$CampsiteLoadingImpl();

  @override
  String toString() {
    return 'CampsiteState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CampsiteLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Campsite> campsites) loaded,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Campsite> campsites)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Campsite> campsites)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CampsiteInitial value) initial,
    required TResult Function(CampsiteLoading value) loading,
    required TResult Function(CampsiteLoaded value) loaded,
    required TResult Function(CampsiteError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CampsiteInitial value)? initial,
    TResult? Function(CampsiteLoading value)? loading,
    TResult? Function(CampsiteLoaded value)? loaded,
    TResult? Function(CampsiteError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CampsiteInitial value)? initial,
    TResult Function(CampsiteLoading value)? loading,
    TResult Function(CampsiteLoaded value)? loaded,
    TResult Function(CampsiteError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class CampsiteLoading implements CampsiteState {
  const factory CampsiteLoading() = _$CampsiteLoadingImpl;
}

/// @nodoc
abstract class _$$CampsiteLoadedImplCopyWith<$Res> {
  factory _$$CampsiteLoadedImplCopyWith(_$CampsiteLoadedImpl value,
          $Res Function(_$CampsiteLoadedImpl) then) =
      __$$CampsiteLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Campsite> campsites});
}

/// @nodoc
class __$$CampsiteLoadedImplCopyWithImpl<$Res>
    extends _$CampsiteStateCopyWithImpl<$Res, _$CampsiteLoadedImpl>
    implements _$$CampsiteLoadedImplCopyWith<$Res> {
  __$$CampsiteLoadedImplCopyWithImpl(
      _$CampsiteLoadedImpl _value, $Res Function(_$CampsiteLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CampsiteState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? campsites = null,
  }) {
    return _then(_$CampsiteLoadedImpl(
      campsites: null == campsites
          ? _value._campsites
          : campsites // ignore: cast_nullable_to_non_nullable
              as List<Campsite>,
    ));
  }
}

/// @nodoc

class _$CampsiteLoadedImpl implements CampsiteLoaded {
  const _$CampsiteLoadedImpl({required final List<Campsite> campsites})
      : _campsites = campsites;

  final List<Campsite> _campsites;
  @override
  List<Campsite> get campsites {
    if (_campsites is EqualUnmodifiableListView) return _campsites;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_campsites);
  }

  @override
  String toString() {
    return 'CampsiteState.loaded(campsites: $campsites)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CampsiteLoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._campsites, _campsites));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_campsites));

  /// Create a copy of CampsiteState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CampsiteLoadedImplCopyWith<_$CampsiteLoadedImpl> get copyWith =>
      __$$CampsiteLoadedImplCopyWithImpl<_$CampsiteLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Campsite> campsites) loaded,
    required TResult Function(String message) error,
  }) {
    return loaded(campsites);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Campsite> campsites)? loaded,
    TResult? Function(String message)? error,
  }) {
    return loaded?.call(campsites);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Campsite> campsites)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(campsites);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CampsiteInitial value) initial,
    required TResult Function(CampsiteLoading value) loading,
    required TResult Function(CampsiteLoaded value) loaded,
    required TResult Function(CampsiteError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CampsiteInitial value)? initial,
    TResult? Function(CampsiteLoading value)? loading,
    TResult? Function(CampsiteLoaded value)? loaded,
    TResult? Function(CampsiteError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CampsiteInitial value)? initial,
    TResult Function(CampsiteLoading value)? loading,
    TResult Function(CampsiteLoaded value)? loaded,
    TResult Function(CampsiteError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class CampsiteLoaded implements CampsiteState {
  const factory CampsiteLoaded({required final List<Campsite> campsites}) =
      _$CampsiteLoadedImpl;

  List<Campsite> get campsites;

  /// Create a copy of CampsiteState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CampsiteLoadedImplCopyWith<_$CampsiteLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CampsiteErrorImplCopyWith<$Res> {
  factory _$$CampsiteErrorImplCopyWith(
          _$CampsiteErrorImpl value, $Res Function(_$CampsiteErrorImpl) then) =
      __$$CampsiteErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$CampsiteErrorImplCopyWithImpl<$Res>
    extends _$CampsiteStateCopyWithImpl<$Res, _$CampsiteErrorImpl>
    implements _$$CampsiteErrorImplCopyWith<$Res> {
  __$$CampsiteErrorImplCopyWithImpl(
      _$CampsiteErrorImpl _value, $Res Function(_$CampsiteErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of CampsiteState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$CampsiteErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CampsiteErrorImpl implements CampsiteError {
  const _$CampsiteErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'CampsiteState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CampsiteErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of CampsiteState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CampsiteErrorImplCopyWith<_$CampsiteErrorImpl> get copyWith =>
      __$$CampsiteErrorImplCopyWithImpl<_$CampsiteErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Campsite> campsites) loaded,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Campsite> campsites)? loaded,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Campsite> campsites)? loaded,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CampsiteInitial value) initial,
    required TResult Function(CampsiteLoading value) loading,
    required TResult Function(CampsiteLoaded value) loaded,
    required TResult Function(CampsiteError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CampsiteInitial value)? initial,
    TResult? Function(CampsiteLoading value)? loading,
    TResult? Function(CampsiteLoaded value)? loaded,
    TResult? Function(CampsiteError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CampsiteInitial value)? initial,
    TResult Function(CampsiteLoading value)? loading,
    TResult Function(CampsiteLoaded value)? loaded,
    TResult Function(CampsiteError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class CampsiteError implements CampsiteState {
  const factory CampsiteError(final String message) = _$CampsiteErrorImpl;

  String get message;

  /// Create a copy of CampsiteState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CampsiteErrorImplCopyWith<_$CampsiteErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CampsiteFilterState {
  CampsiteFilter get filter => throw _privateConstructorUsedError;
  List<String> get availableCountries => throw _privateConstructorUsedError;
  List<String> get availableLanguages => throw _privateConstructorUsedError;
  double get minPrice => throw _privateConstructorUsedError;
  double get maxPrice => throw _privateConstructorUsedError;

  /// Create a copy of CampsiteFilterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CampsiteFilterStateCopyWith<CampsiteFilterState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CampsiteFilterStateCopyWith<$Res> {
  factory $CampsiteFilterStateCopyWith(
          CampsiteFilterState value, $Res Function(CampsiteFilterState) then) =
      _$CampsiteFilterStateCopyWithImpl<$Res, CampsiteFilterState>;
  @useResult
  $Res call(
      {CampsiteFilter filter,
      List<String> availableCountries,
      List<String> availableLanguages,
      double minPrice,
      double maxPrice});

  $CampsiteFilterCopyWith<$Res> get filter;
}

/// @nodoc
class _$CampsiteFilterStateCopyWithImpl<$Res, $Val extends CampsiteFilterState>
    implements $CampsiteFilterStateCopyWith<$Res> {
  _$CampsiteFilterStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CampsiteFilterState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? filter = null,
    Object? availableCountries = null,
    Object? availableLanguages = null,
    Object? minPrice = null,
    Object? maxPrice = null,
  }) {
    return _then(_value.copyWith(
      filter: null == filter
          ? _value.filter
          : filter // ignore: cast_nullable_to_non_nullable
              as CampsiteFilter,
      availableCountries: null == availableCountries
          ? _value.availableCountries
          : availableCountries // ignore: cast_nullable_to_non_nullable
              as List<String>,
      availableLanguages: null == availableLanguages
          ? _value.availableLanguages
          : availableLanguages // ignore: cast_nullable_to_non_nullable
              as List<String>,
      minPrice: null == minPrice
          ? _value.minPrice
          : minPrice // ignore: cast_nullable_to_non_nullable
              as double,
      maxPrice: null == maxPrice
          ? _value.maxPrice
          : maxPrice // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }

  /// Create a copy of CampsiteFilterState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CampsiteFilterCopyWith<$Res> get filter {
    return $CampsiteFilterCopyWith<$Res>(_value.filter, (value) {
      return _then(_value.copyWith(filter: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CampsiteFilterStateImplCopyWith<$Res>
    implements $CampsiteFilterStateCopyWith<$Res> {
  factory _$$CampsiteFilterStateImplCopyWith(_$CampsiteFilterStateImpl value,
          $Res Function(_$CampsiteFilterStateImpl) then) =
      __$$CampsiteFilterStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {CampsiteFilter filter,
      List<String> availableCountries,
      List<String> availableLanguages,
      double minPrice,
      double maxPrice});

  @override
  $CampsiteFilterCopyWith<$Res> get filter;
}

/// @nodoc
class __$$CampsiteFilterStateImplCopyWithImpl<$Res>
    extends _$CampsiteFilterStateCopyWithImpl<$Res, _$CampsiteFilterStateImpl>
    implements _$$CampsiteFilterStateImplCopyWith<$Res> {
  __$$CampsiteFilterStateImplCopyWithImpl(_$CampsiteFilterStateImpl _value,
      $Res Function(_$CampsiteFilterStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of CampsiteFilterState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? filter = null,
    Object? availableCountries = null,
    Object? availableLanguages = null,
    Object? minPrice = null,
    Object? maxPrice = null,
  }) {
    return _then(_$CampsiteFilterStateImpl(
      filter: null == filter
          ? _value.filter
          : filter // ignore: cast_nullable_to_non_nullable
              as CampsiteFilter,
      availableCountries: null == availableCountries
          ? _value._availableCountries
          : availableCountries // ignore: cast_nullable_to_non_nullable
              as List<String>,
      availableLanguages: null == availableLanguages
          ? _value._availableLanguages
          : availableLanguages // ignore: cast_nullable_to_non_nullable
              as List<String>,
      minPrice: null == minPrice
          ? _value.minPrice
          : minPrice // ignore: cast_nullable_to_non_nullable
              as double,
      maxPrice: null == maxPrice
          ? _value.maxPrice
          : maxPrice // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$CampsiteFilterStateImpl implements _CampsiteFilterState {
  const _$CampsiteFilterStateImpl(
      {required this.filter,
      required final List<String> availableCountries,
      required final List<String> availableLanguages,
      required this.minPrice,
      required this.maxPrice})
      : _availableCountries = availableCountries,
        _availableLanguages = availableLanguages;

  @override
  final CampsiteFilter filter;
  final List<String> _availableCountries;
  @override
  List<String> get availableCountries {
    if (_availableCountries is EqualUnmodifiableListView)
      return _availableCountries;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_availableCountries);
  }

  final List<String> _availableLanguages;
  @override
  List<String> get availableLanguages {
    if (_availableLanguages is EqualUnmodifiableListView)
      return _availableLanguages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_availableLanguages);
  }

  @override
  final double minPrice;
  @override
  final double maxPrice;

  @override
  String toString() {
    return 'CampsiteFilterState(filter: $filter, availableCountries: $availableCountries, availableLanguages: $availableLanguages, minPrice: $minPrice, maxPrice: $maxPrice)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CampsiteFilterStateImpl &&
            (identical(other.filter, filter) || other.filter == filter) &&
            const DeepCollectionEquality()
                .equals(other._availableCountries, _availableCountries) &&
            const DeepCollectionEquality()
                .equals(other._availableLanguages, _availableLanguages) &&
            (identical(other.minPrice, minPrice) ||
                other.minPrice == minPrice) &&
            (identical(other.maxPrice, maxPrice) ||
                other.maxPrice == maxPrice));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      filter,
      const DeepCollectionEquality().hash(_availableCountries),
      const DeepCollectionEquality().hash(_availableLanguages),
      minPrice,
      maxPrice);

  /// Create a copy of CampsiteFilterState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CampsiteFilterStateImplCopyWith<_$CampsiteFilterStateImpl> get copyWith =>
      __$$CampsiteFilterStateImplCopyWithImpl<_$CampsiteFilterStateImpl>(
          this, _$identity);
}

abstract class _CampsiteFilterState implements CampsiteFilterState {
  const factory _CampsiteFilterState(
      {required final CampsiteFilter filter,
      required final List<String> availableCountries,
      required final List<String> availableLanguages,
      required final double minPrice,
      required final double maxPrice}) = _$CampsiteFilterStateImpl;

  @override
  CampsiteFilter get filter;
  @override
  List<String> get availableCountries;
  @override
  List<String> get availableLanguages;
  @override
  double get minPrice;
  @override
  double get maxPrice;

  /// Create a copy of CampsiteFilterState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CampsiteFilterStateImplCopyWith<_$CampsiteFilterStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
